#!/usr/bin/env python3

from jinja2 import Template
import markdown
import os
import argparse
import shutil
import yaml

from data.generator.html import html_from_file

parser = argparse.ArgumentParser(description='Generates the website from sources in the provided folder.')
parser.add_argument('source', type=str, help='directory with source files')
parser.add_argument('output', type=str, default='output', help='directory to output into')

args = parser.parse_args()

def render_table(type):
	return html_from_file(type, os.path.join('data', f'{type}-data.yml'))

def generate_navbar(basedir, data, current_page):
	"""
	Generates a HTML list of pages from the provided navbar data.

	The data is a list of tuples in a format of (filename, prettyname), where:
	  - filename is the name of the file, without the extension;
	  - prettyname is the name that will be displayed on the site; this can be
	    None, in which case it will be autogenerated.

	If the filename ends with a dot, it's treated as a subfolder with an index
	file.
	"""
	navbar = "<ul>"

	for filename, prettyname in data:
		if not prettyname:
			prettyname = filename.replace('-', ' ').capitalize()

		if filename.endswith('.'):
			filepath = filename[:-1] + '/index.html'
		else:
			filepath = filename + '.html'

		if current_page == filename:
			navbar += f'<li><span class="selected">{prettyname}</span></li>'
		else:
			navbar += f'<li><a href="{basedir}/{filepath}">{prettyname}</a></li>'

	navbar += '</ul>'
	return navbar

def render_template(html_path, md_path=None, footer_path=None,
					navbar_data=None, data={}):
	"""Renders the template for the provided file."""
	with open(html_path) as file:
		template = Template(file.read())
		template.globals['table'] = render_table

		if footer_path:
			with open(footer_path) as footer_file:
				data["footer"] = footer_file.read().rstrip()
		if navbar_data:
			current_page = os.path.basename(html_path).split('.')[0]
			data["navbar"] = generate_navbar(navbar_data[0], navbar_data[1], current_page)
		if md_path:
			with open(md_path) as md_file:
				data["markdown"] = markdown.markdown(md_file.read())
				data["pagename"] = md_file.read().split('\n', 1)[0].replace('# ', '')

		return template.render(data)

# TODO: this runs in two loops because it initially was meant to generate
# the navbar, now that that's done in a separate script we may be able to
# move it all back to one loop
# although this code is pretty clean imo so it might not be necessary
def scan_directory(directory, output_dir):
	if not os.path.exists(output_dir):
		os.mkdir(output_dir)

	templatable_files = []
	subdirectories = []
	base_path = None
	footer_path = None

	# Load template data
	navbar_data = []
	navbar_data_path = os.path.join(directory, 'navbar.yml')
	if os.path.exists(navbar_data_path):
		with open(navbar_data_path) as navbar_data_file:
			_navbar_data = yaml.safe_load(navbar_data_file.read())
		if _navbar_data:
			for filename, prettyname in _navbar_data.items():
				navbar_data.append( (filename, prettyname) )

	# First pass; get templatable files
	for filename in os.listdir(directory):
		full_path = os.path.join(directory, filename)

		if os.path.isdir(full_path):
			subdirectories.append(filename)

		elif filename.endswith('html'):
			if filename == 'base.html':
				base_path = full_path
			elif filename == 'footer.html':
				footer_path = full_path
			else:
				templatable_files.append(filename)

		elif filename.endswith('md'):
			templatable_files.append(filename)

		else:
			shutil.copyfile(full_path, os.path.join(output_dir, filename))

	output_basedir = output_dir.replace(args.output, '').replace('\\', '/')
	if output_basedir.endswith('/'):
		output_basedir = output_basedir[:-1]

	navbar_data = (output_basedir, navbar_data)

	if not footer_path:
		parent_footer = os.path.join(
			os.path.abspath(os.path.join(full_path, os.pardir)),
			'footer.html'
			)

		if os.path.exists(parent_footer):
			footer_path = parent_footer

	# Clean up templatable files
	# After this step, this will only contain HTML files and MD files that use
	# a base template.
	_templatable_files = []
	markdownable_files = []
	for filename in templatable_files:
		if filename.endswith('.html'):
			_templatable_files.append(filename)
		elif filename.endswith('.md'):
			if filename.replace('.md', '.html') not in templatable_files:
				if base_path:
					_templatable_files.append(filename)
				else:
					full_path = os.path.join(directory, filename)
					print(f"WARNING: File {full_path} doesn't have a corresponding .html file! It will not be included in the final website.")
			else:
				markdownable_files.append(filename)
	templatable_files = _templatable_files

	# Second pass; render templates
	for filename in templatable_files:
		full_path = os.path.join(directory, filename)

		if filename.endswith('.html'):
			md_path = None
			if filename.replace('.html', '.md') in markdownable_files:
				md_path = full_path.replace('.html', '.md')

			target_path = os.path.join(output_dir, filename)
			with open(target_path, 'w') as target_file:
				target_file.write(render_template(
					full_path, md_path, footer_path, navbar_data
				))

		elif filename.endswith('.md'):
			# This is guaranteed to use base.html due to the cleanup done earlier
			target_path = os.path.join(output_dir, filename.replace('.md', '.html'))
			with open(target_path, 'w') as target_file:
				target_file.write(render_template(
					base_path, full_path, footer_path, navbar_data
				))

	# Third pass; scan all subdirectories
	if subdirectories:
		for filename in subdirectories:
			full_path = os.path.join(directory, filename)
			if not os.path.exists(os.path.join(full_path, '.noscan')):
				scan_directory(full_path, os.path.join(output_dir, filename))

scan_directory(args.source, args.output)
